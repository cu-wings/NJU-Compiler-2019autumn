# <center>编译原理实验报告</center>

<center>171860570_周吴成，161220144向扬帆</center>
### 1.实验目标

在词法分析、语法分析和语义分析程序的基础上编写一个程序，对C--源代码翻译为中间代码。

### 2.实验内容

1. 操作数结构构造
   + 对照实验手册给出的结构，操作数的种类分为5种：源代码中的变量，常量，临时变量，函数名，标号，另外还有为了指示操作数存储的数据类型的type，在输出时根据指示在变量前添加"*"或者"&"符号。
   
     ![操作数类型](D:\课件\作业\大三上\编译原理\实验三\操作数类型.png)
     
     其中，union中的内容根据操作数的种类存储不同的值，当操作数为源代码中的变量或其地址时，union中存储其标号和源代码中名称；当操作数为临时变量或标号时，存储其标号；当操作数为常量时，存储其值；当操作数为函数时，存储其名称。
   
2. 中间代码结构构造
   
     + 构造线性中间代码结构，每条代码由种类、操作数构成，这里根据操作数数量将中间代码的存储分为四类。
     
     
     ![中间代码类型](D:\课件\作业\大三上\编译原理\实验三\中间代码类型.png)
     
     
     
3. 变量列表构造

   + 变量列表的格式为：

     ![变量列表](D:\课件\作业\大三上\编译原理\实验三\变量列表.png)

     使用一个双向链表构造变量列表，存储所有源代码中出现的变量，op类型为VARIABLE，当遇到一个源代码中的变量时，在列表中寻找并返回一个Operand。

4. 中间代码生成实现简述

+ 准备工作

   + 在开始生成中间代码之前，需要首先在语义分析前将read和write函数加入符号表中以便不出现语义错误。

+ 中间代码的生成的步骤
  
   + 由于本实验中的假设，可以得知所有在本实验中出现的变量大小都为4的倍数，除了数组和结构类型变量以外，所有的变量都为4字节的int或是float类型，并且除了数组和结构体以外，定义变量均不需要生成额外的中间代码，只需要在定义时为该变量创建一个VARIABLE类型操作数并将其加入变量列表即可。
   
   + 使用实验一中生成的语法树和实验二中生成的符号表，我们能够通过遍历语法树建立中间代码节点。
   
   + 表达式Exp、语句Stmt、条件表达式Cond是生成中间代码的主要部分，对照实验手册的内容创建临时变量、标号、常量以及中间代码，由于该部分内容与实验手册内容重合，因此不再赘述。
   
   + 函数调用需要创建ARG代码传入实参，传入的顺序与参数列表的顺序恰好相反，由于在建立符号表时，符号表中函数参数的域结构在建立时采取了头插法生成链表，因此传入参数只需要根据函数参数域的链顺序传入即可。
   
   + 对于数组或是结构体类型的变量，在传入参数时需要对其进行取地址操作，为了能够实现便捷的判断，在操作数结构中加入了ADDRESS和VAL两个种类的type，由于在设计中只有变量之前能够出现取地址符号，只有临时变量之前会出现取值符号，因此在输出时可以用type域的值来判断变量前是否需要添加符号。
   
+ 特殊处理
  
   + 中间代码逻辑优化：根据课上所讲的内容，可以将if-GOTO类型的语句转化为ifFalse-GOTO类型的语句来精简代码逻辑，这样就需要修改Stmt、Cond和Exp函数中的内容，将原本生成2个label的if语句转化为只生成一个label的ifFalse语句，再根据之后是否有else生成第二个label，代码逻辑如下：
   
     ![精简ifFalse](D:\课件\作业\大三上\编译原理\实验三\精简ifFalse.png)
   
     此处将原本的truelabel置为空，减少了标号的生成语句，因此需要在对应的Cond函数中进行条件的修改。
   
     ![relop](D:\课件\作业\大三上\编译原理\实验三\relop.png)
   
     relop语句中使用了一个Inverse_operator函数，该函数的功能是将relop的判断取反，即将“>”符号改为"<="符号，同样的，在其他对应的处理也需要将符号取反或是true和false的标签取反。
   
     ![精简示例](D:\课件\作业\大三上\编译原理\实验三\精简示例.png)
     
     示例中显示了实验手册示例1精简后的中间代码，原本的逻辑判断变为相反，减少了GOTO语句的使用。
     
     同时，去除了将常量存储在一个临时变量的中间代码，而选择直接将常量填入需要的变量处。
     
   + 选做3.2部分：为了数组的函数参数调用，我们的实现方式如上所述，变量类型加入ADDRESS类型代表地址，这样同样可以用于进行高维数组的访问。
     
       在遇到高维数组时，需要跟随语法树结构从低到高逐层访问，获取该维度的偏移量并且乘上该维度的空间大小。
     
     ![高维数组](D:\课件\作业\大三上\编译原理\实验三\高维数组.png)
     
     如代码所示，在循环中每次生成一条乘法和加法指令代表每次计算出偏移量并累加，最后生成一条取值代码获取该处地址中的值。

4. 其他

   本小组为第10组，完成选做3.2部分。

   编译方式与原本编译方式一致，Makefile文件中添加了scanner的伪目标。

### 3.小组成员

周吴成 171860570 邮箱：zwx847447133@126.com

向扬帆 161220144 邮箱：272338868@qq.com