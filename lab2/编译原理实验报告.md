# <center>编译原理实验报告</center>

<center>171860570_周吴成，161220144向扬帆</center>
### 1.实验目标

在词法分析和语法分析程序的基础上编写一个程序，对C--源代码进行语义分析和类型检查，并打印分析结果。

### 2.实验内容

1. 类型结构构造
   + 对照实验手册给出的类型结构，在其基础上添加了两种类型：函数类型FUNCTION和结构类型变量类型STRUCTVAR，原有的STRUCTURE作为结构体类型。
   
     ![变量类型](D:\课件\作业\大三上\编译原理\实验二\变量类型.png)
   
     其中，函数类型使用function域作为其成员，ret为函数返回值类型，param利用与结构体相似的链式结构来存储形参列表中所有变量的类型；而结构类型STRUCTVAR和结构体类型STRUCTURE都使用structure作为其成员，实际上，STRUCTVAR类型的structure的type域连接的正是该结构类型变量的结构体类型。
   
     也就是说，函数的类型结构为：Type ret | param =  (Type)a.tail -> (Type)b.tail -> (Type)c
   
     结构类型变量的结构为 STRUCTVAR structure -> type STRUCTURE -> (Type)a.tail -> (Type)b.tail -> ...
     
     
   
2. 符号表构造
   + 符号表的构造比较简单，在这里选择采用实现简单而且高效的散列表来实现符号表。
   
     符号表需要变量的名称、变量第一次出现的行号、变量是否被定义还是仅被声明、变量的类型。
   
     符号表的结构如下：
   
     ![符号表](D:\课件\作业\大三上\编译原理\实验二\符号表.png)
   
     由于使用散列表，为了避免碰撞，在这里使用开散列法实现。
     
     
   
3. 语义分析实现简述
   
+ 语义分析主要需要实现的是符号表的读写与变量类型的判断。
  
   + 由于本实验中的假设，可以得知所有在本实验中出现的变量都为全局变量，因此需要将任何一个出现的变量装入符号表或是判断重定义，因此跟在类型标识符Specifier之后的变量实际上均为变量定义。因此除了选做2.1的函数声明，其余变量加入符号表时都将defined置为true。
   
   + 在实验一中构建了一颗语法树，其结构与C--的文法结构相同，因此可以将每一个非终结符的产生式处理封装为一个函数，通过函数参数和返回值来传递其继承属性和综合属性。
   
   + 我们将所有在程序中出现的变量都加入符号表中，包括函数名，函数的形参名，结构体名，结构体中的域名。
   
   + 由于结构体在定义时的特殊性，需要在定义时判断其域名是否与之前的域名重复，因此我们将结构体定义的相关部分与非结构体定义的部分拆分，用下标_Structure作为区分。
   
   + 特殊处理
   
     + 结构体定义：在定义结构体中的域时，需要知道在定义该域之前的所有本结构体中的域名，但在结构体定义完成前，符号表中是没有该结构体的，而我们也并不知道符号表中的变量是否属于当前结构体，因此在定义结构体的域时，需要将整个结构体的所有域名作为继承属性传递给当前正要定义域的函数。而其他情况并不需要，只需要到符号表中查找是否有同名变量即可。
   
     + 结构类型变量：在定义结构类型变量时，需要结构体的类型和结构体名称，而我们在查找符号表得到的类型只是结构体的类型，其中存储着结构体的所有域名和域的类型，此时我们使用STRUCTVAR类型，将STRUCTURE类型作为其structure域的type，即STRUCTVAR类型的type即为STRUCTURE。实际上，由于我们使Specifier函数返回一个Type类型作为之后定义变量的类型，因为定义变量时变量的类型不会是STRUCTURE结构体类型，因此我们只需要在定义结构体类型，将其加入符号表后，返回一个由其构成的STRUCTVAR类型，即可实现结构类型变量的定义。实际上，STRUCTURE类型只在符号表中出现作为一个类型标识，并不会作为实际的变量的类型。
   
     + 选做2.1部分：为了实现函数的声明，我们需要首先改写文法，实际上由于函数声明只不过是在函数定义的文法上去除了大括号中内容且添加了分号作为结束标识，因此文法的修改只需要简单的添加一句：ExtDef -> Specifier FunDec SEMI
   
       ![文法添加](D:\课件\作业\大三上\编译原理\实验二\文法添加.png)
   
       这样即可实现函数的声明。为了能够体现声明和定义的区别，此时符号表中的defined项发挥了重要的作用，在函数声明时，加入符号表的函数名defined为false，而只有在定义和声明的函数名的类型相同（即返回值类型相同，且形参的数目和类型都相同）时，才会将该函数的defined置为true。为了实现错误提示19，则需要额外增加一个函数，该函数需要遍历所有的FUNCTION类型变量，确认它们的defined是否为true，由于符号表的大小并不太大，这里采用在符号表构造完毕（即已经完成对于语法树的遍历）后，遍历符号表，寻找defined为false的FUNCTION类型变量。
   
     + 实现表达式类型的推导：表达式类型的推导可直接由其产生式的类型推导得出，在代码上体现为Exp的返回类型构成了上层Exp的类型，除了左值的判断可以直接由产生式的形式规定以外，其他的表达式类型错误均在Exp函数中进行判断。
   
4. 其他

   本小组为第10组，完成选做2.1部分。

   编译方式与原本编译方式一致，Makefile文件中添加了scanner的伪目标。

### 3.小组成员

周吴成 171860570 邮箱：zwx847447133@126.com

向扬帆 161220144 邮箱：272338868@qq.com